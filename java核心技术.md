## java的特点

1)简单性     7)  可移植性
2)面向对象   8)  解释型
3)分布式     9)  高性能 
4)健壮性    10)  多线程
5)安全性     11) 动态性
6)体系结构中立

### 1.2.1 简单性
 java没有头文件、指针运算(甚至指针语法)、结构、联合、操作符重载、虚基类


### 1.2.2 面向对象
Java与C++的主要不同点在于多重继承，在Java，取而代之的是更简单的接口，java提供了更丰富的运行时自省功能

### 1.2.3 分布式
Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议.Java应用程序能够通过URL打开和访问网络上的对象

### 1.2.4 健壮性
Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早起的问题检测、后期动态的(运行时)检测，并消除了容易出错的情况......Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏的可能性

### 1.2.5 安全性

Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。
    .  运行时堆栈溢出。如蠕虫和病毒常用的攻击手段。
    .  破坏自己的进程空间之外的内存
    .  未经授权读写文件

 不可信代码在一个沙箱环境中执行，在这里它不会影响主系统。

 ### 1.2.6 体系结构中立

    编译器生成一个体系结构中立的目标文件格式(编译过得代码)，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。字节码不仅可以在任何机器上解释执行，还能动态地翻译成本地机器代码。
    
    解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译
  Java 虚拟机还有一些其他的优点。它可以检测指令序列的行为 ，从而增强其安全性 。
    
 ### 1.2.7 可移植性

   与C和C++不同，Java规范中没有"依赖具体实现"的地方。基本数据类型的大小以及有关的运算都做了明确的说明"。
   如：Java中的int永远为32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一限制只是int类型的大小不能低于short int,并且不能高于long int。在Java中，数据类型具有固定的大小，消除了代码移植是的主要问题。二进制数据以固定的格式进行存储和传输，消除了直接顺序的问题。字符串是用标准的Unicode格式存储的

 ### 1.2.8 解释型
    Java解释器可以在任何移植了解释器的机器上执行Java字节码。链接是一个增量式且轻量级的过程

 ### 1.2.9 高性能

 字节码可以(在运行时刻)动态地翻译成对应运行这个应用的特定 CPU的机器码

 ### 1.2.10 多线程
     多线程可以带来更好的交互响应和实时行为 。

### 1.2.11 动态性
从各种角度看 ，Java与C或C+ +相比更加具有动态性。它能够适应不断发展的环境库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响 。 在Java中找出运行时类型信息十分简单 。



## 第3章

Java中的所有函数都属于某个类的方法(标准术语将其称为方法，而不是成员函数)。

### 3.3 数据类型
Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型:在Java中，共有8种基本类型(primitive type)，其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。

整数被0除将会产生一个异常，而浮点数被0除将会得到无穷大或NaN结果


>>>运算符用0填充高位， 
>>用符号位填充高位，
不存在<<<运算符。

不能修改Java字符串中的字符，在Java文档中将String类对象称为不可变字符串 

## 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。

由类构造(construct)对象的过程称为创建类的实例(instance)。对象中的数据称为实例域(instance field),操纵数据的过程称为方法(method ) 。 对于每个特定的类实例 （ 对象 ） 都有一组特定的实例域值 。这些值的集合就是这个对象的当前状态（ state ) 。无论何时，只要向对象发送一个消息 ，它的状态就有可能发生改变 

实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了 “ 黑盒 ” 特征 ， 这是提高重用性和可靠性的关键 。 这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据 ， 其他对象就不会知道或介意所发生的变化。

 通过扩展一个类来建立另外一个类的过程称为继承 （ inheritance )

 

 要想使用 OOP ，一定要清楚对象的三个主要特性
 • 对象的行为(behavior) — 可以对对象施加哪些操作,或可以对对象施加哪些方法 ？
 • 对象的状态(state) — 当施加那些方法时，对象如何响应 ？
 • 对象标识(identity) — 如何辨别具有相同行为与状态的不同对象 ？
                                                             
                                                             
每个对象都保存着描述当前特征的信息 。这就是对象的状态 。对象的状态可能会随着时间而发生改变， 但这种改变不会是自发的 。对象状态的改变必须通过调用方法实现( 如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏 ) 。                                          
 对象的状态并不能完全描述一个对象 。每个对象都有一个唯一的身份(identity) 。 

 • 商品 （ Item )
 • 订单 （ Order )
 • 送货地址 （ Shipping address )
 • 付 款 ( Payment )
 • 账户 （ Account )


 在类之间，最常见的关系有
 **• 依赖（ “uses - a ” ）**
 **• 聚合（“ has - a ” ）**
 **• 继承（“is - a ” ）**
 依赖 （ dependence ) , 即 “uses - a ” 关系 ，是一种最明显的 、最常见的关系。


 如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类 。应该尽可能地将相互依赖的类减至最少。 如果类A 不知道 B 的存在 ， 它就不会关心 B的任何改变（ 这意味着 B 的改变不会导致 A 产生任何 bug ) 。用软件工程的术语来说，就是让类之间的耦合度最小。

 聚合 （ aggregation ) , 即 “ has - a ” 关系 ， 是一种具体且易于理解的关系。 例如 ，一个Order 对象包含一些 Item 对象 。 聚合关系意味着类 A 的对象包含类 B 的对象 。



![1556401629163](C:\Users\michaelhee\AppData\Roaming\Typora\typora-user-images\1556401629163.png)


继承 （ inheritance ) , 即 “ is - a ” 关系， 是一种用于表示特殊与一般关系的 。

Violet UML Editor



![1556401868950](C:\Users\michaelhee\AppData\Roaming\Typora\typora-user-images\1556401868950.png)


要想使用对象， 就必须首先构造对象 ， 并指定其初始状态 。 然后 ，对对象应用方法 。在 Java 程序设计语言中 ， 使用构造器(constructor) 构造新实例 。构造器是一种特殊的方法 。用来构造并初始化对象 。

构造器的名字应该与类名相同。 因此Date 类的构造器名为 Date。

一个对象变量并没有实际包含一个对象， 而仅仅引用一个对象。


在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用。

• 构造器与类同名
• 每个类可以有一个以上的构造器
• 构造器可以有0 个 、 1 个或多个参数
• 构造器没有返回值
• 构造器总是伴随着new 操作一起调用 

如果多个方法（ 比如 ，StringBuilder构造器方法 ）有相同的名字 、不同的参数，便产生了重载 。 

如果在编写一个类时没有编写构造器 ，那么系统就会提供一个无参数构造器 。这个构造器将所有的实例域设置为默认值。实例域中的数值型数据设置为 0 、 布尔型数据设置为 false、 所有对象变量将设置为 null 。如果类中提供了至少一个构造器， 但是没有提供无参数的构造器 ， 则在构造对象时如果没有提供参数就会被视为不合法。 







##  redis

redis-server.exe redis.windows.conf

